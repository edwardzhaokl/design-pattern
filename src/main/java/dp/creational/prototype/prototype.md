### 原型模式 - Prototype Pattern  
学习难度：★★★☆☆  
使用频率：★★★☆☆  

1. 动机  
用原型实例指定创建对象的种类, 并且通过拷贝这些原型创建新的对象.  

2. 适用性  
(1) 当一个系统应该独立于它的产品创建, 构成和表示时;  
(2) 当要实例化的类是在运行时刻指定的, 例如通过动态装载;  
(3) 为了避免创建一个与产品类层次平行的工厂类层次时;  
(4) 当一个类的实例只能有几个不同状态组合中的一种时,  
建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些.  

3. 结构  
* Prototype:  
声明一个克隆自身的接口  
* ConcretePrototype:  
实现一个克隆自身的接口  
* Client  
让一个原型克隆自身从而创建一个新的对象,  
在客户类中只需要直接实例化或者通过工厂方法等方式创建一个原型对象,  
再通过调用该对象的克隆方法即可得到多个相同的对象.  

原型模式的核心在于 `如何实现克隆方法`  

通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其
返回，并将相关的参数传入新创建的对象中，保证它们的成员属性相同。

1. Java 语言提供的 clone() 方法  
所有的 Java 类都继承自 Object类, Object类提供了 clone()方法.  
能够实现克隆的 Java 类必须实现一个标识接口Cloneable, 表示这个类支持被复制.  
如果一个类没有实现这个接口而被调用了 clone()方法, 则会抛异常: CloneNotSupportException.  
Java 中的 clone()方法需满足:  对任何对象 x
(1) x.clone() != x  
(2) x.clone().getClass() == x.getClass()  
(3) x.clone().equals(x) == true  

最佳实践:  
(1) 子类覆盖父类的 clone()方法, 并声明为 public;  
(2) 在子类的 clone()方法中, 调用 super.clone();  
(3) 子类需实现Cloneable 接口;  
此时, Object 类相当于抽象原型类, 所有实现了 Cloneable 接口的类相当于具体原型类.

##### 1. 浅克隆

如果原型对象的成员是值类型, 则复制一份给克隆对象;  
如果原型对象的成员是对象类型, 则将引用对象的地址复制一份给克隆对象,  
也就是说, 原型对象和克隆对象的成员变量指向相同的内存地址.

##### 2.深克隆  
可通过序列化方式实现.  
序列化就是将对象写到流的过程, 写到流中的对象是原对象的拷贝, 而原对象仍存在于内存中.  


原型管理器是将多个原型对象存储在一个集合中供客户端使用, 是一个专门负责克隆对象的工厂,  
其中定义了一个集合用于存储原型对象.




